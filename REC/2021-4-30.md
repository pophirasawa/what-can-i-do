睡了+玩了一天 这好吗 这不好

今天学了下树上倍增 大概

不过没写题（？

###### CF1519D

给两串数字，可以翻转a串的一个子序列，让sum a[i]*b[i]最大

我们分奇偶枚举子串的中心，每次扩展l和r，这玩意只有新增的左右端点会对答案产生影响

对影响求max，加上原数组的乘积和即可

感觉跟上次写过的某个题有点像啊（



###### CF932D

看了这玩意，顺便学了下树上倍增

其实这个东西的写法，还挺像写倍增求lca的（？

fa【i】【j】维护点i的第2^j个大于i点的祖先

sum【i】【j】维护i点到第2^j个大于i点的祖先的权值和

然后j从最大开始往下跑，如果sum【i】【j】<=w，更新w，然后i点跳到那个祖先上就行



怎么更新点呢

首先如果新点比上个点小，直接更新fa【++cnt】【0】=R

如果没有 就往上找从max0到0第一个比W小的，更新节点，然后继续往上走

```c++
int y = x;
        for (int i = 20; i >= 0; i--){
            if (w[fa[y][i]] < w[cnt])
                y = fa[y][i]; //i一直在减，更新y后，fa[y][i]肯定是在大于W[cnt]和小于w[cnt]的值中间 这个也和LCA一毛一样啊
        }
        fa[cnt][0] = fa[y][0]; 
```

后面就是正常更新了，早上我试试写一下。。

