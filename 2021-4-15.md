感觉这一整周都很怠惰，什么原理

把昨天没搞出来的俩题补了，然后昏迷了，绷不住了

###### CF1511E

关于dp，用dp[i]\[0/1]来保存长度为i的格子，最后一位为蓝/红的贡献个数

如果最后一个和倒数第二个都是蓝色且放上了牌子这玩意对前面i-2个格子所有的涂色方式都有贡献

有2^（i-2），加上原来的dp[i-2]就是这种情况的贡献和，然后加上倒数第二个是红色的贡献即可

如果最后一个是红色，不能加摆牌，直接就是dp[i-1]

所以有以下转移

```c++
dp[i][0] = dp[i - 1][0] + dp[i - 1][1]d;
dp[i][1] = pows[i - 2]+dp[i-2][1]+dp[i-2][0]+dp[i-1][0];
//pows是预处理的2的幂
```

预处理dp数组即可



###### CF1513F

看错题了。。这玩意只能交换一次

如果要能减小cost，当且仅当两个a，b对 对应的区间有重合 而且一个对a>b 另外个a<b 才行 画图意会下就完了

把a<b的对放到一个集合X，剩下另外个集合Y 这样例如我们当前的数在集合X里，要找到可以和这玩意配对的Y

只需要在Y找到个b比a小，且a最大的对即可 

可以用神奇map预处理集合中前n个最大的值啥的



